<script>
  var DraggableAnswer = {
    gallery: null,
    trash: null,
    deleteItem: function (item, insertHere) {
      if (insertHere.find(".exercise-draggable-answer-option").length > 0) {
        return false;
      }

      item.fadeOut(function () {
        var $list = $('ul', insertHere).length
          ? $('ul', insertHere)
          : $('<ul>').addClass('gallery list-unstyled').appendTo(insertHere);

        var droppedId = item.attr('id'),
          dropedOnId = insertHere.attr('id'),
          originSelectId = 'window_' + droppedId + '_select',
          value = dropedOnId.split('_')[2];

        $('#' + originSelectId + ' option')
          .filter(function (index) {
            var position = insertHere.prop('id').split('_')[2];
            return index === parseInt(position);
          })
          .prop("selected", true);

        item.appendTo($list).fadeIn();
      });
    },
    recycleItem: function (item) {
      var droppedId = item.attr('id'),
        originSelectId = 'window_' + droppedId + '_select',
        idParts = droppedId.split('_'),
        questionId = parseInt(idParts[0]) || 0;

      if (!questionId) {
        return;
      }

      item.fadeOut(function () {
        item
          .appendTo(DraggableAnswer.gallery.filter('[data-question="' + questionId + '"]'))
          .fadeIn();

        DraggableAnswer.trash.children('.gallery').each(function () {
          var $el = $(this);
          if ($el.children().length === 0) {
            $el.remove();
          }
        });
      });

      $('#' + originSelectId + ' option').prop('selected', false);
      $('#' + originSelectId + ' option:first').prop('selected', true);
    },
    init: function (gallery, trash) {
      this.gallery = gallery;
      this.trash = trash;

      $("li", DraggableAnswer.gallery).draggable({
        cancel: "a.ui-icon",
        revert: "invalid",
        containment: "document",
        helper: "clone",
        cursor: "move"
      });

      DraggableAnswer.trash.droppable({
        accept: ".exercise-draggable-answer > li.touch-items",
        tolerance: "pointer",
        drop: function (e, ui) {
          DraggableAnswer.deleteItem(ui.draggable, $(this));
        }
      });

      DraggableAnswer.gallery.droppable({
        tolerance: "pointer",
        drop: function (e, ui) {
          DraggableAnswer.recycleItem(ui.draggable, $(this));
        }
      });
    }
  };

  var MatchingDraggable = {
    colorDestination: '#316B31',
    curviness: 0,
    connectorType: 'Straight',
    initialized: false,
    instances: {},
    init: function (questionId) {
      // Create (or reuse) one jsPlumb instance per question
      var instance = MatchingDraggable.instances[questionId] || jsPlumb.getInstance();
      MatchingDraggable.instances[questionId] = instance;

      // Bind to the actual question container for correct offsets
      var container =
        document.getElementById('question_div_' + questionId) ||
        document.querySelector('.main-question') ||
        document.body;
      instance.setContainer(container);

      // Safety: remove previous endpoints if re-init happens
      try { instance.deleteEveryEndpoint(); } catch (e) {}

      var windowQuestionSelector = '.window' + questionId + '_question';
      var windowAnswerSelector   = '.window' + questionId + '_answer';

      var countConnections = $(windowQuestionSelector).length;
      var colorArray            = $.xcolor.analogous("#da0",     countConnections > 0 ? countConnections : 10);
      var colorArrayDestination = $.xcolor.analogous("#51a351",  countConnections > 0 ? countConnections : 10);

      var scope = questionId + "_scope";

      var exampleDropOptions = {
        tolerance: 'touch',
        hoverClass: 'dropHover',
        activeClass: 'dragActive'
      };

      var originalColors = {};

      var destinationEndPoint = {
        endpoint: ["Dot", { radius: 15 }],
        paintStyle: { fill: MatchingDraggable.colorDestination },
        isSource: false,
        connectorStyle: { stroke: MatchingDraggable.colorDestination, strokeWidth: 8 },
        connector: [ MatchingDraggable.connectorType, { curviness: MatchingDraggable.curviness } ],
        maxConnections: 1000,
        isTarget: true,
        dropOptions: exampleDropOptions,
        scope: scope,
        beforeDrop: function (params) {
          // Reset color and ensure 1 connection per source
          instance.selectEndpoints().each(function (endpoint) {
            var sourceId = endpoint.elementId;
            if (originalColors[sourceId]) {
              endpoint.setPaintStyle({ fill: originalColors[sourceId] });
            }
          });
          instance.select({ source: params.sourceId }).each(function (connection) {
            instance.detach(connection);
          });

          // Reflect selection in hidden <select>
          var selectId = params.sourceId + "_select";
          var value = parseInt(params.targetId.split("_")[2], 10);

          $("#" + selectId + " option")
            .prop('selected', false)
            .filter(function (index) { return index === value; })
            .prop("selected", true);

          return true;
        }
      };

      // Sources (left column)
      $(windowQuestionSelector).each(function (index) {
        var windowId = this.id;
        if (!windowId) return;

        var color = colorArray[index].getHex();
        originalColors[windowId] = color;

        var sourceEndPoint = {
          endpoint: [ "Dot", { radius: 15 } ],
          paintStyle: { fill: color },
          isSource: true,
          connectorStyle: { stroke: "#8a8888", strokeWidth: 8 },
          connector: [ MatchingDraggable.connectorType, { curviness: MatchingDraggable.curviness } ],
          maxConnections: 1,
          isTarget: false,
          dropOptions: exampleDropOptions,
          scope: scope
        };

        instance.addEndpoint(windowId, { anchor: "RightMiddle" }, sourceEndPoint);
      });

      // Targets (right column) with guards to avoid orphan endpoints at (0,0)
      if ($(windowAnswerSelector).length) {
        // Preferred: explicit answer boxes exist
        $(windowAnswerSelector).each(function (index) {
          var targetId = this.id;
          if (!targetId) return;
          destinationEndPoint.paintStyle.fill = colorArrayDestination[index].getHex();
          instance.addEndpoint(targetId, { anchor: "LeftMiddle" }, destinationEndPoint);
        });
      } else {
        // Fallback: derive id from source id + "_answer" ONLY if the node exists
        $(windowQuestionSelector).each(function (index) {
          var derivedId = this.id + "_answer";
          if (!document.getElementById(derivedId)) return;
          destinationEndPoint.paintStyle.fill = colorArrayDestination[index].getHex();
          instance.addEndpoint(derivedId, { anchor: "LeftMiddle" }, destinationEndPoint);
        });
      }

      MatchingDraggable.attachBehaviour();
    },
    attachBehaviour: function () {
      if (!MatchingDraggable.initialized) {
        MatchingDraggable.initialized = true;
        setTimeout(function () { repaintAllJsPlumbInstances(); }, 300);
        $(window).on('resize orientationchange scroll', repaintAllJsPlumbInstances);
      }
    }
  };

  jsPlumb.ready(function () {
    if ($(".drag_question").length > 0) {

      $(window).on('resize orientationchange', function () {
        repaintAllJsPlumbInstances();
      });

      $(document).on('scroll', function () {
        repaintAllJsPlumbInstances();
      });
    }
  });

  function repaintAllJsPlumbInstances() {
    if (typeof MatchingDraggable.instances !== "undefined") {
      Object.values(MatchingDraggable.instances).forEach(function (instance) {
        instance.repaintEverything();
      });
    } else {
      jsPlumb.repaintEverything();
    }
  }

  function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
  }

  $(function () {
    if ('{{ shuffle_answers }}' === '1') {
      $('.exercise-draggable-answer').each(function () {
        var $ul = $(this);
        var li = $ul.find('.touch-items');
        var liContents = [];
        li.each(function () {
          liContents.push($(this));
        });
        shuffleArray(liContents);
        $ul.empty().html(liContents);
      });
    }

    DraggableAnswer.init(
      $(".exercise-draggable-answer"),
      $(".droppable")
    );

    // Use the layout-aware initializer so endpoints are placed
    // only when the question area has its final size.
    initMatchingWithRetry();
  });

  /* -----------------------------
   * Robust layout-aware initializer
   * -----------------------------
   * Purpose: avoid "first render bad / second good" by waiting until boxes have real sizes.
   * Triggers: jsPlumb.ready, window.load, BFCache pageshow.
   * Also cleans up instances on pagehide.
   */
  function initMatchingWithRetry(maxTries = 40, delay = 100) {
    let tries = 0;

    function ready() {
      // Detect question ids from classes .window{qid}_question
      const qids = new Set();
      document.querySelectorAll('[class]').forEach(el => {
        (el.className || '').toString().split(/\s+/).forEach(c => {
          const m = /^window(\d+)_question$/.exec(c);
          if (m) qids.add(m[1]);
        });
      });

      if (qids.size === 0) {
        // Nothing yet: retry soon
        return (++tries < maxTries) ? void setTimeout(ready, delay) : void 0;
      }

      // Ensure all relevant boxes have non-zero size
      const boxes = [];
      qids.forEach(qid => {
        document.querySelectorAll('.window' + qid + '_question').forEach(el => boxes.push(el));
        document.querySelectorAll('.window' + qid + '_answer').forEach(el => boxes.push(el));
        // Fallback targets derived from source ids
        document.querySelectorAll('.window' + qid + '_question').forEach(src => {
          const fb = document.getElementById(src.id + '_answer');
          if (fb) boxes.push(fb);
        });
      });

      const sized = boxes.length > 0 && boxes.every(el => el && el.offsetWidth > 0 && el.offsetHeight > 0);
      if (!sized) {
        return (++tries < maxTries) ? void setTimeout(ready, delay) : void 0;
      }

      // Layout is stable: init per question
      qids.forEach(qid => {
        try { MatchingDraggable.init(qid); } catch (e) {}
      });

      // Extra repaints to cover slow layouts (tests tool, fonts, etc.)
      setTimeout(repaintAllJsPlumbInstances, 0);
      setTimeout(repaintAllJsPlumbInstances, 300);
      setTimeout(repaintAllJsPlumbInstances, 800);
    }

    ready();
  }

  // Launch the robust initializer at safe moments
  jsPlumb.ready(function () { initMatchingWithRetry(); });
  $(window).on('load', function () { initMatchingWithRetry(); });
  window.addEventListener('pageshow', function () { initMatchingWithRetry(); });

  // Clean-up when leaving the page (helps with BFCache and re-entries)
  window.addEventListener('pagehide', function () {
    try {
      Object.values(MatchingDraggable.instances || {}).forEach(i => {
        if (i && i.reset) i.reset();
        else if (i && i.deleteEveryEndpoint) i.deleteEveryEndpoint();
      });
      MatchingDraggable.instances = {};
      MatchingDraggable.initialized = false;
    } catch (e) {}
  });
</script>
